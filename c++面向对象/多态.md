多态分为静态多态和动态多态,实现了接口和实现进行分类，提高代码的复用性 扩展性 解耦能力

## 静态多态

### 函数重载 编译期确定

i. 允许在同一作用域中声明多个功能相似的同名函数

ii.依靠函数参数个数、类型、顺序不同区别

iii.不能通过返回值类型来区别 （1.很多函数没有返回值  2.隐饰类型转换下无法区分

****原理：

函数名修饰，编译过程分为 

预处理:

头文件中的函数声明拷贝到源文件 避免编译阶段找不到函数定义)

编译:

语法分析，同时进行符号汇总(函数名 )

汇编:

生成函数名到函数地址的映射，方便之后通过函数名找到函数定义的位置 去执行函数

链接:

将多个文件中的符号表汇总合并

查看符号表：objdump -t [二进制文件]    _Z + 类长度 +类名+函数名长度+函数名+E+参数类型首字母

## 类模板和函数模板 编译期确定

### 函数模板

允许定义一种通用的函数形式 某些类型是参数化的 编译器通过调用的实际类型参数生成对应的函数版本

### 类模板

允许定义一种通用的类形式  某些类型是参数化的  编译器通过调用的实际类型参数生成特定类型的类

****原理：

函数名修饰，编译过程分为 

预处理:

头文件中的函数声明拷贝到源文件 避免编译阶段找不到函数定义)

编译:

语法分析，同时进行符号汇总(函数名 )

汇编:

生成函数名到函数地址的映射，方便之后通过函数名找到函数定义的位置 去执行函数

链接:

将多个文件中的符号表汇总合并

查看符号表：objdump -t [二进制文件]    _Z + 类长度 +类名+函数名长度+函数名+E+类型首字母

## 动态多态

### 虚函数和继承  运行时确定

### 虚函数重写

在基类的前加上virtual关键字，在派生类重写该函数

运行时会根据对象的类型来调用相应的函数

****原理：

早绑定：编译器编译时已经确定对象调用函数的地址

晚绑定：

i.若类使用virtual函数，则编译器会为该类生成虚函数表(一维数组)，存放了虚函数的地址，类对象构造时候会初始化指向该虚表的指针，存放在类对象的最前边

ii.虚函数表指针是在构造函数的时候初始化的

****多继承的情况下 
派生类会为每一个包含虚函数的直接基类都维护一个独立的虚函数表指针 每个虚函数表指针都指向对应类的虚函数表，派生类重写了父类的虚函数，就会在虚函数表中将父类的虚函数地址替换成派生类的虚函数/函数地址

****菱形继承

A-》B     A-》C    B、C-》D     

i.虚继承的方式解决菱形继承二义性的问题，编译器会为每一个虚继承的类对象生成虚基类表，存储当前对象到共享基类的偏移量

ii.此时D中存储顶层的基类成员只有一份，虚函数指针数量 等于包含虚函数的基类数量





****虚函数、虚函数表、虚表指针在内存的什么区域

虚函数      代码段

虚函数表  常量区

虚表指针  取决于对象是在栈区还是堆区创建

****虚函数表、虚表指针的创建时机

虚函数表是在编译的时候 发现类中含有virtual修饰的函数，生成虚函数表(一维数组)，存放了虚函数的地址

虚表指针是在类对象构造的时候 初始化虚表指针 将虚表指针指向虚函数表的地址，继承的情况 下 会先调基类的构造，虚表指针指向 基类的虚函数表地址，接着调子类的构造，虚表指针指向 子类的虚函数表地址