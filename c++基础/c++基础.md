1.extern "C" 作用

C++ 支持**函数重载**，而 C 语言不支持 

**对花括号内的代码，按照 C 语言的规则编译（不做名字修饰），同时在链接时也按照 C 的符号名查找**。

**C 编译器**：

编译函数时，直接以「函数名」作为符号名（比如 `void func(int)` 编译后符号名就是 `func`）

**C ++编译器**：

_Z + 类长度 +类名+函数名长度+函数名+E+参数类型首字母

2.堆和栈的区别 哪个快

****管理方式上

 堆是程序员手动进行管理的 手动申请 和释放 容易导致内存泄漏 或 悬空指针

 栈是编译器自动进行管理的，无需手动释放 

****系统分配方式上

OS收到堆上的空间分配申请 ，这里操作系统是用链表来管理空闲内存区域，堆是不连续区域，需要遍历维护空闲内存区域的链表，找到第一个大于申请空间的节点，从空闲内存区域链表中移除，正式分配给程序，堆操作涉及内存管理复杂，效率低且极容易造成内存碎片，降低效率，但可以获取更大的内存 

OS收到栈上的空间分配申请的时候，栈是已经分配好的连续的内存，只要申请空间小于栈的剩余空间就能分配，否则栈溢出，栈大小受系统预设限制，编译器可以更改

此外，栈是OS提供的数据结构，也就是计算机底层对栈提供支持，栈操作是底层指令效率高 

 3.enum class 和 enum的区别          

在C++中，有两种方式可以定义枚举类型：`enum` 和 `enum class`。

​			作用域限定性：

​			`enum`：枚举值可以直接使用枚举值的名称，枚举值的名称在相同作用域下是可见的，可能会导致名称冲突。

​			`enum class`：枚举值需要通过作用域解析运算符 `::` 来访问，枚举值的名称在枚举类的作用域内是局部的，不会与其他作用域中的名称冲突。

​		类型安全上：

- - `enum`：枚举值可以隐式转换为其底层类型（通常是整数类型），并且可以与整数类型进行比较。
  - `enum class`：枚举值不会隐式转换为其底层类型，需要显式转换为底层类型，它们与整数类型之间没有隐式的比较操作

- 